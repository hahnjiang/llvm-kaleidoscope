# 10. 总结和其他有用的 LLVM 花絮

## 10.1 教程总结

欢迎阅读“使用 LLVM 实现语言”教程的最后一章。在本教程的过程中，我们已经将我们的小万花筒语言从一个无用的玩具发展为一个半有趣（但可能仍然无用）的玩具。 :)

看看我们已经走了多远，用了多少代码，这很有趣。我们构建了整个词法分析器、解析器、AST、代码生成器、交互式运行循环（使用 JIT！），并在独立的可执行文件中发出调试信息 - 所有这些都在 1000 行（非注释/非空白）代码中。

我们的小语言支持几个有趣的特性：它支持用户定义的二元和一元运算符，它使用 JIT 编译进行即时评估，它支持一些具有 SSA 结构的控制流结构。

本教程的部分想法是向您展示定义、构建和使用语言是多么容易和有趣。构建编译器不必是一个可怕或神秘的过程！现在您已经了解了一些基础知识，我强烈建议您获取代码并对其进行破解。例如，尝试添加：

* **全局变量** — 虽然全局变量在现代软件工程中的价值值得怀疑，但它们在组合快速的小黑客时通常很有用，比如 Kaleidoscope 编译器本身。幸运的是，我们当前的设置使得添加全局变量变得非常容易：只需在拒绝它之前进行值查找检查以查看未解析的变量是否在全局变量符号表中。要创建新的全局变量，请创建 LLVM ```GlobalVariable``` 类的实例。
* **类型变量** - Kaleidoscope 目前仅支持双精度类型的变量。这使该语言非常优雅，因为只支持一种类型意味着您永远不必指定类型。不同的语言有不同的处理方式。最简单的方法是要求用户为每个变量定义指定类型，并在符号表中记录变量的类型及其 Value*。
* **数组、结构、向量等** — 一旦你添加了类型，你就可以开始以各种有趣的方式扩展类型系统。简单数组非常简单，对许多不同的应用程序都非常有用。添加它们主要是学习 LLVM getelementptr 指令如何工作的练习：它非常漂亮/非常规，它有自己的常见问题解答！
* **标准运行时** — 我们当前的语言允许用户访问任意外部函数，我们将它用于“printd”和“putchard”之类的东西。当您扩展语言以添加更高级别的构造时，如果将这些构造降低到调用语言提供的运行时，这些构造通常最有意义。例如，如果您将哈希表添加到语言中，那么将例程添加到运行时可能更有意义，而不是一直内联它们。
* **内存管理** — 目前我们只能在 Kaleidoscope 中访问堆栈。能够通过调用标准 libc malloc/free 接口或垃圾收集器来分配堆内存也很有用。如果您想使用垃圾收集，请注意 LLVM 完全支持精确垃圾收集，包括移动对象和需要扫描/更新堆栈的算法。
* **异常处理支持** — LLVM 支持生成零成本异常，它可以与用其他语言编译的代码进行互操作。您还可以通过隐式地让每个函数返回一个错误值并检查它来生成代码。您还可以显式使用 setjmp/longjmp。有许多不同的方式可以到达这里。
* **面向对象、泛型、数据库访问、复数、几何编程……** - 真的，您可以向该语言添加的疯狂功能无穷无尽。
* **不寻常的领域** — 我们一直在谈论将 LLVM 应用于许多人感兴趣的领域：为特定语言构建编译器。但是，还有许多其他领域可以使用通常不被考虑的编译器技术。例如，LLVM 已被用于实现 OpenGL 图形加速、将 C++ 代码转换为 ActionScript 以及许多其他可爱而聪明的东西。也许您将是第一个使用 LLVM 将正则表达式解释器 JIT 编译为本机代码的人？

玩得开心 - 尝试做一些疯狂和不寻常的事情。像其他人一样构建一门语言，比尝试一些有点疯狂或不合时宜的事情并看看结果如何要有趣得多。如果您遇到困难或想讨论它，请在 [LLVM 论坛](https://discourse.llvm.org)上发帖：它有很多对语言感兴趣的人并且通常愿意提供帮助。

在我们结束本教程之前，我想谈谈生成 LLVM IR 的一些“提示和技巧”。这些是一些可能不明显的更微妙的东西，但如果您想利用 LLVM 的功能，它们将非常有用。

## 10.2 LLVM IR 的属性

我们有几个关于 LLVM IR 形式的代码的常见问题 - 让我们现在就解决这些问题，好吗？

### 10.2.1 目标独立

Kaleidoscope 是“可移植语言”的一个例子：用 Kaleidoscope 编写的任何程序在其运行的任何目标上都将以相同的方式工作。许多其他语言具有此属性，例如lisp、java、haskell、javascript、python 等（请注意，虽然这些语言是可移植的，但并非所有的库都是可移植的）。

LLVM 的一个好处是它通常能够在 IR 中保持目标独立性：您可以将 LLVM IR 用于 Kaleidoscope 编译的程序并在 LLVM 支持的任何目标上运行它，甚至发出 C 代码并在目标上编译它 LLVM 本身不支持。您可以简单地看出 Kaleidoscope 编译器生成了与目标无关的代码，因为它在生成代码时从不查询任何特定于目标的信息。

LLVM 提供了一种紧凑的、目标无关的代码表示这一事实让很多人兴奋不已。不幸的是，这些人在询问有关语言可移植性的问题时，通常会想到 C 或 C 家族的语言。我说“不幸的是”，因为除了运送源代码之外，真的没有办法使（完全通用的）C 代码可移植（当然，C 源代码实际上也不是一般可移植的 - 曾经移植过一个非常老的从 32 位到 64 位的应用程序？）。

C 的问题（再一次，在其完全通用性方面）是它充满了目标特定的假设。作为一个简单的例子，预处理器在处理输入文本时通常会破坏性地从代码中删除目标独立性：

``` cpp
    #ifdef __i386__
      int X = 1;
    #else
      int X = 42;
    #endif
```

虽然可以针对此类问题设计越来越复杂的解决方案，但无法以比交付实际源代码更好的方式完全通用地解决它。

也就是说，有一些有趣的 C 子集可以移植。如果您愿意将基本类型固定为固定大小（比如 int = 32 位，long = 64 位），不关心 ABI 与现有二进制文件的兼容性，并且愿意放弃一些其他次要功能，你可以有可移植的代码。这对于诸如内核语言之类的专门领域很有意义。

### 10.2.2 安全保证

上面的许多语言也是“安全”语言：用 Java 编写的程序不可能破坏其地址空间并使进程崩溃（假设 JVM 没有错误）。安全是一个有趣的属性，它需要语言设计、运行时支持和操作系统支持的组合。

在 LLVM 中实现安全语言当然是可以的，但是 LLVM IR 本身并不能保证安全。 LLVM IR 允许不安全的指针转换、释放错误后使用、缓冲区溢出和各种其他问题。安全需要作为 LLVM 之上的一个层来实现，而且，方便的是，几个小组已经对此进行了调查。如果您对更多详细信息感兴趣，请在 [LLVM 论坛](https://discourse.llvm.org)上提问。

### 10.2.3 特定语言的优化

LLVM 让很多人望而却步的一件事是它不能在一个系统中解决世界上所有的问题。一个具体的抱怨是人们认为 LLVM 无法执行高级特定于语言的优化：LLVM“丢失了太多信息”。以下是对此的一些观察：

首先，你是对的，LLVM 确实会丢失信息。例如，在撰写本文时，无法在 LLVM IR 中区分 SSA 值是来自 ILP32 机器上的 C“int”还是 C“long”（调试信息除外）。两者都被编译成一个“i32”值，关于它来自什么的信息丢失了。这里更普遍的问题是，LLVM 类型系统使用“结构等价”而不是“名称等价”。另一个让人吃惊的地方是，如果你在高级语言中有两种具有相同结构的类型（例如，具有单个 int 字段的两个不同结构）：这些类型将编译成单个 LLVM 类型，这将是不可能的告诉它是从哪里来的。

其次，虽然 LLVM 确实会丢失信息，但 LLVM 并不是一个固定的目标：我们继续以许多不同的方式增强和改进它。除了添加新功能（LLVM 并不总是支持异常或调试信息）之外，我们还扩展了 IR 以捕获用于优化的重要信息（例如，参数是符号扩展还是零扩展，有关指针别名的信息等）。许多增强功能都是用户驱动的：人们希望 LLVM 包含一些特定功能，因此他们继续扩展它。

第三，添加特定于语言的优化是可能且容易的，而且您在如何进行优化方面有多种选择。作为一个简单的例子，很容易添加特定于语言的优化通道，这些优化通道“知道”关于为一种语言编译的代码的事情。对于 C 系列，有一个“了解”标准 C 库函数的优化过程。如果您在 main() 中调用“exit(0)”，它知道将其优化为“return 0”是安全的；因为 C 指定了“exit”函数的作用。

除了简单的库知识外，还可以将各种其他特定于语言的信息嵌入到 LLVM IR 中。如果您有特定需求并遇到困难，请在 llvm-dev 列表中提出该主题。在最坏的情况下，您总是可以将 LLVM 视为“哑代码生成器”，并在特定于语言的 AST 上在前端实现您想要的高级优化。

## 10.3 技巧和窍门

在处理/使用 LLVM 之后，您会了解到许多乍一看并不明显的有用提示和技巧。本节不让大家重新发现它们，而是讨论其中的一些问题。

### 10.3.1 实现可移植的 offsetof/sizeof

出现的一件有趣的事情是，如果您试图让编译器生成的代码“与目标无关”，您通常需要知道某些 LLVM 类型的大小或 llvm 结构中某些字段的偏移量。例如，您可能需要将类型的大小传递给分配内存的函数。

不幸的是，这可能因目标而异：例如，指针的宽度通常是特定于目标的。但是，有一种[巧妙的方法可以使用 getelementptr 指令](http://nondot.org/sabre/LLVMNotes/SizeOf-OffsetOf-VariableSizedStructs.txt)，使您能够以可移植的方式进行计算。

### 10.3.2 垃圾回收栈帧

一些语言希望显式管理它们的栈帧，通常这样它们就可以被垃圾回收或允许轻松实现闭包。通常有比显式堆栈帧更好的方法来实现这些功能，但如果您愿意，[LLVM 确实支持它们](http://nondot.org/sabre/LLVMNotes/ExplicitlyManagedStackFrames.txt)。它需要您的前端将代码转换为 [Continuation Passing Style](http://en.wikipedia.org/wiki/Continuation-passing_style) 并使用尾调用（LLVM 也支持）。